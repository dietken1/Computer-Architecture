# 컴퓨터 구조 PA3 보고서 - 202126892 소프트웨어학과 정원준

## 목차

1. [소개](#소개)
2. [types.h 파일 분석](#typesh-파일-분석)
3. [__run_cycle 메서드 분석](#__run_cycle-메서드-분석)
4. [Stage별 구현](#stage별-구현)
   1. [IF Stage](#if-stage)
   2. [ID Stage](#id-stage)
   3. [EX Stage](#ex-stage)
   4. [MEM Stage](#mem-stage)
   5. [WB Stage](#wb-stage)
5. [명령어별 처리 방식](#명령어별-처리-방식)
   1. [lw 명령어](#lw-명령어)
   2. [sw 명령어](#sw-명령어)
   3. [beq & bne 명령어 + Control Hazard 처리 방법](#beq--bne-명령어--control-hazard-처리-방법)
   4. [j & jal 명령어](#j--jal-명령어)
6. [Forwarding 구현 Idea](#forwarding-구현-idea)
7. [결론](#결론)

---

## 소개

이 보고서는 컴퓨터 구조 실습 3(PA3)에서의 프로세서 파이프라인 구현을 다룹니다. 저는 해당 프로젝트에서 주어진 파일들을 분석하고, 각 Stage를 구현하여 MIPS 프로세서에서의 파이프라인 연산을 시뮬레이션하는 프로그램을 작성했습니다. 각 명령어를 올바르게 처리하기 위한 방법을 다루고, Pipeline Register의 역할과 Pipeline Hazards 해결 방법을 논의합니다.

---

## types.h 파일 분석

PA3에서의 주요 작업은 MIPS 프로세서의 파이프라인을 구현하는 것입니다. 이를 위해 `types.h` 파일을 분석한 결과, 4개의 중요한 파이프라인 레지스터—`IF_ID`, `ID_EX`, `EX_MEM`, `MEM_WB`—가 정의되어 있다는 것을 알았습니다. 이 레지스터들은 각 Stage에서 발생한 값을 전달하는 데 필수적입니다. 각 파이프라인 Stage에서는 해당 레지스터를 통해 다음 Stage로 값을 전달하며, 이 값들이 제대로 관리되지 않으면 파이프라인에서 오류가 발생할 수 있습니다.

---

## __run_cycle 메서드 분석

`__run_cycle` 메서드는 MIPS 프로세서의 각 사이클을 실행하는 핵심 메서드로, 각 Stage의 동작을 역순으로 호출하여 실행합니다. 이 방식은 **Stall** 상태나 **Control Hazard**를 처리할 때 유용합니다.

1. **Stall 처리:** 각 Stage가 Stall 상태일 경우 해당 Stage는 수행되지 않습니다.
2. **WB Stage:** ALU 연산 결과를 레지스터에 반영하거나 메모리에서 읽은 데이터를 레지스터에 씁니다.
3. **MEM Stage:** 메모리에서 데이터를 읽거나 쓰는 작업을 수행합니다.
4. **EX Stage:** ALU를 통해 연산을 수행합니다.
5. **ID Stage:** 명령어를 해석하고, 필요한 레지스터 값을 읽어옵니다.
6. **IF Stage:** 다음 명령어를 메모리에서 읽어옵니다.

이 메서드는 파이프라인에서 발생할 수 있는 여러 가지 문제를 해결하는 중요한 역할을 합니다.

---

## Stage별 구현

### IF Stage

IF Stage에서는 명령어를 메모리에서 읽어옵니다. 처음에는 PC 값을 이용해 명령어를 읽었지만, 엔디안 문제로 인해 빅엔디안 형식으로 명령어를 읽도록 수정했습니다. 또한, PC 값을 4씩 증가시키고, 이를 `IF_ID` 레지스터에 전달하여 후속 Stage로 전달됩니다.

### ID Stage

ID Stage에서는 `IF_ID` 레지스터에 저장된 명령어를 해석하여 필요한 레지스터 값을 추출합니다. 특히, **sign-extend** 처리와 **J-format 명령어**의 예외 처리에 신경을 썼습니다. J-format의 경우, 즉시값을 다르게 처리하여 점프 주소가 올바르게 설정되도록 했습니다.

### EX Stage

EX Stage에서는 ALU를 사용하여 연산을 수행합니다. 예외적인 명령어(lw, sw, beq 등)에 대한 처리가 중요하며, 이를 처리하기 위해 각 명령어의 opcode와 funct 값에 맞춰 동작을 구현했습니다. 예를 들어, `beq` 명령어의 경우 두 레지스터 값을 비교하여 점프 여부를 결정합니다.

### MEM Stage

MEM Stage에서는 메모리 작업을 수행합니다. `lw` 명령어의 경우, EX Stage에서 계산된 주소를 바탕으로 메모리에서 값을 읽어오고, `sw` 명령어의 경우 메모리에 값을 씁니다. EX Stage에서 계산된 메모리 주소를 MEM Stage로 전달하여 올바르게 값을 읽거나 쓸 수 있도록 했습니다.

### WB Stage

WB Stage에서는 연산 결과를 레지스터에 반영하는 작업을 수행합니다. 특히 `lw` 명령어에서는 메모리에서 읽어온 값을 `MEM_WB` 레지스터를 통해 레지스터에 반영하고, 다른 명령어들은 이미 이전 Stage에서 연산이 완료되므로 특별한 작업을 수행하지 않습니다.

---

## 명령어별 처리 방식

### lw 명령어

`lw` 명령어는 레지스터에서 값을 읽어와 메모리 주소를 계산하는 과정에서 **빅엔디안** 방식으로 메모리 값을 읽어오는 부분이 중요합니다. EX Stage에서 계산된 주소를 MEM Stage에서 메모리로 읽어와 `MEM_WB` 레지스터를 통해 결과를 `WB Stage`에서 레지스터에 반영합니다.

### sw 명령어

`sw` 명령어는 메모리 주소를 계산하여 해당 메모리 위치에 값을 씁니다. EX Stage에서 계산된 주소를 MEM Stage로 전달하고, MEM Stage에서는 그 주소에 값을 기록하는 작업을 수행합니다.

### beq & bne 명령어 + Control Hazard 처리 방법

`beq`와 `bne` 명령어는 **Control Hazard**를 처리해야 합니다. 이를 해결하기 위해 ID Stage에서 branch 명령어를 감지하고, IF Stage에서 **Stall**을 걸어줍니다. 이후 EX Stage에서 점프 여부를 판단하여 PC 값을 갱신합니다.

### j & jal 명령어

`j`와 `jal` 명령어는 무조건 점프를 수행합니다. 이 명령어들은 `ID Stage`에서 Stall을 걸고, EX Stage에서 점프할 주소를 계산하여 MEM Stage에서 PC 값을 갱신합니다.

---

## Forwarding 구현 Idea

Forwarding은 파이프라인에서 발생할 수 있는 **Data Hazard**를 해결하는 방법입니다. EX Stage에서 연산된 값을 MEM Stage나 WB Stage에서 사용할 수 있도록 전달하여, 불필요한 Stall을 방지할 수 있습니다. 예를 들어, EX Stage에서 연산된 값을 EX_MEM 레지스터로 전달하고, MEM Stage에서는 이를 ALU 연산 전에 사용할 수 있도록 합니다. 이를 통해 명령어 간 데이터 의존성을 해결할 수 있습니다.

---

## 배운점

이번 PA3 프로젝트를 통해 MIPS 프로세서의 파이프라인을 효과적으로 구현할 수 있었습니다. 각 Stage의 동작을 정확히 파악하고, 이를 구현하는 과정에서 **Stall**, **Forwarding**, **Control Hazard** 등 다양한 파이프라인 관련 문제들을 해결할 수 있었습니다. 이를 통해 프로세서의 기본 동작 원리와 성능 향상을 위한 기법들에 대해 이해할 수 있었습니다.
